<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[install Thrift on CentOS 6.5]]></title>
    <url>%2F2018%2F12%2F29%2Fthrift%2Finstall_thrift_on_centos6.5%2F</url>
    <content type="text"><![CDATA[更新系统1yum update 安装平台开发包1yum groupinstall &quot;Development Tools&quot; 更新 autoconf1234567wget http://ftp.gnu.org/gnu/autoconf/autoconf-2.69.tar.gztar xvf autoconf-2.69.tar.gzcd autoconf-2.69./configure --prefix=/usrmakemake installcd .. 更新automake1234567wget http://ftp.gnu.org/gnu/automake/automake-1.14.tar.gztar xvf automake-1.14.tar.gzcd automake-1.14./configure --prefix=/usrmakemake installcd .. 更新bison1234567wget http://ftp.gnu.org/gnu/bison/bison-2.5.1.tar.gztar xvf bison-2.5.1.tar.gzcd bison-2.5.1./configure --prefix=/usrmakemake installcd .. 添加C++依赖包1yum install libevent-devel zlib-devel openssl-devel 安装boost12345wget http://sourceforge.net/projects/boost/files/boost/1.53.0/boost_1_53_0.tar.gztar xvf boost_1_53_0.tar.gzcd boost_1_53_0./bootstrap.sh./b2 install 安装Thrift123456git clone https://github.com/apache/thrift.gitcd thrift./bootstrap.sh./configure --with-lua=nomakemake install 问题1234567891011# 错误提示g++: error: /usr/local/lib/libboost_unit_test_framework.a: No such file or directory# 解决yum install boost-devel-static# 执行make任出现该问题，后来发现安装位置不在 /usr/local/lib/find / -name &quot;libboost_unit_test_framework.a&quot;# 在 /usr/lib64/ 目录下# 建立软连接ln -s /usr/lib64/libboost_unit_test_framework.a /usr/local/lib/libboost_unit_test_framework.a]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>thrift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hive元数据表结构详解]]></title>
    <url>%2F2018%2F09%2F11%2Fhive%2Fhive_metadata_info%2F</url>
    <content type="text"><![CDATA[转自 存储Hive版本的元数据表(VERSION) VER_ID SCHEMA_VERSION VERSION_COMMENT ID主键 Hive版本 版本说明 1 1.2.0 Set by MetaStore 如果该表出现问题，根本进入不了Hive-Cli。比如该表不存在，当启动Hive-Cli时候，就会报错”Table ‘hive.version’ doesn’t exist”。 Hive数据库相关的元数据表(DBS、DATABASE_PARAMS)DBS 该表存储Hive中所有数据库的基本信息，字段如下: 表字段 说明 示例数据 DB_ID 数据库ID 1 DESC 数据库描述 Default Hive database DB_LOCATION_URI 数据HDFS路径 hdfs://hadoop-cluster/user/hive/warehouse NAME 数据库名 default OWNER_NAME 数据库所有者用户名 public OWNER_TYPE 所有者角色 1 DATABASE_PARAMS 该表存储数据库的相关参数，在CREATE DATABASE时候用WITH DBPROPERTIES(property_name=property_value, …)指定的参数。 表字段 说明 示例数据 DB_ID 数据库ID 1 PARAM_KEY 参数名 createdby PARAM_VALUE 参数值 root DBS和DATABASE_PARAMS这两张表通过DB_ID字段关联。 Hive表和视图相关的元数据表 主要有TBLS、TABLE_PARAMS、TBL_PRIVS，这三张表通过TBL_ID关联。 TBLS 该表中存储Hive表，视图，索引表的基本信息 表字段 说明 示例数据 TBL_ID 表ID 1 CREATE_TIME 创建时间 1447675704 DB_ID 数据库ID 1 LAST_ACCESS_TIME 上次访问时间 1447675704 OWNER 所有者 root RETENTION 保留字段 0 SD_ID 序列化配置信息 41，对应SDS表中的SD_ID TBL_NAME 表名 t_test_1 TBL_TYPE 表类型 MANAGED_TABLE VIEW_EXPANDED_TEXT 视图的详细HQL语句 VIEW_ORIGINAL_TEXT 视图的原始HQL语句 TABLE_PARAMS 该表存储表/视图的属性信息 表字段 说明 示例数据 TBL_ID 表ID 1 PARAM_KEY 属性名 numRows、totalSize PARAM_VALUE 属性值 6、24 TBL_PRIVS 该表存储表/视图的授权信息 表字段 说明 示例数据 TBL_GRANT_ID 授权ID 1 CREATE_TIME 授权时间 1436320455 GRANT_OPTION 0 GRANTOR 授权执行用户 root GRANTOR_TYPE 授权者类型 USER PRINCIPAL_NAME 被授权用户 username PRINCIPAL_TYPE 被授权用户类型 USER TBL_PRIV 权限 Select、Alter TBL_ID 表ID 21，对应TBLS表的TBL_ID Hive文件存储信息相关的元数据表 主要涉及SDS、SD_PARAMS、SERDES、SERDE_PARAMS，由于HDFS支持的文件格式很多，而建Hive表时候也可以指定各种文件格式，Hive在将HQL解析成MapReduce时候，需要知道去哪里，使用哪种格式去读写HDFS文件，而这些信息就保存在这几张表中。 SDS 该表保存文件存储的基本信息，如INPUT_FORMAT、OUTPUT_FORMAT、是否压缩等。TBLS表中的SD_ID与该表关联，可以获取Hive表的存储信息。 表字段 说明 示例数据 SD_ID 存储信息ID 10 CD_ID 字段信息ID 161454，对应CDS表 INPUT_FORMAT 文件输入格式 org.apache.hadoop.hive.ql.io.parquet.MapredParquetInputFormat IS_COMPRESSED 是否压缩 0 IS_STOREDASSUBDIRECTORIES 是否以子目录存储 0 LOCATION HDFS路径 hdfs://hadoop-cluster/user/hive/warehouse/fact.db/fact_warehouse NUM_BUCKETS 分桶数量 0 OUTPUT_FORMAT 文件输出格式 org.apache.hadoop.hive.ql.io.parquet.MapredParquetOutputFormat SERDE_ID 序列化类ID 4991,对应SERDES表 SD_PARAMS 该表存储Hive存储的属性信息，在创建表时候使用STORED BY ‘storage.handler.class.name’ [WITH SERDEPROPERTIES (…)指定。 表字段 说明 示例数据 SD_ID 存储配置ID 1 PARAM_KEY 存储属性名 PARAM_VALUE 存储属性值 SERDES 该表存储序列化使用的类信息 表字段 说明 示例数据 SERDE_ID 序列化类配置ID 4991 NAME 序列化类别名 NULL SLIB 序列化类 org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe SERDE_PARAMS 该表存储序列化的一些属性、格式信息，比如:行、列分隔符 表字段 说明 示例数据 SERDE_ID 序列化类配置ID 4991 PARAM_KEY 属性名 serialization.format PARAM_VALUE 属性值 1 Hive表字段相关的元数据表COLUMNS_V2 该表存储表对应的字段信息 表字段 说明 示例数据 CD_ID 字段信息ID 575 COMMENT 字段注释 NULL COLUMN_NAME 字段名 name TYPE_NAME 字段类型 string INTEGER_IDX 字段顺序 1 Hive表分分区相关的元数据表 主要涉及PARTITIONS、PARTITION_KEYS、PARTITION_KEY_VALS、PARTITION_PARAMS PARTITIONS 该表存储表分区的基本信息 表字段 说明 示例数据 PART_ID 分区ID 3351 CREATE_TIME 分区创建时间 1479886276 LAST_ACCESS_TIME 最后一次访问时间 0 PART_NAME 分区名 p_day=2016-11-23 SD_ID 分区存储ID 5026 TBL_ID 表ID 1751 PARTITION_KEYS 该表存储分区的字段信息 表字段 说明 示例数据 TBL_ID 表ID 1 PKEY_COMMENT 分区字段说明 分区日期 PKEY_NAME 分区字段名 p_day PKEY_TYPE 分区字段类型 string INTEGER_IDX 分区字段顺序 0 PARTITION_KEY_VALS 该表存储分区字段值 表字段 说明 示例数据 PART_ID 分区ID 3351 PART_KEY_VAL 分区字段值 2016-11-23 INTEGER_IDX 分区字段值顺序 0 PARTITION_PARAMS 该表存储分区的属性信息 表字段 说明 示例数据 PART_ID 分区ID 3351 PARAM_KEY 分区属性名 totalSize PARAM_VALUE 分区属性值 37212837 其他不常用的元数据表DB_PRIVS 数据库权限信息表。通过GRANT语句对数据库授权后，将会在这里存储。 IDXS 索引表，存储Hive索引相关的元数据 INDEX_PARAMS 索引相关的属性信息 TAB_COL_STATS 表字段的统计信息。使用ANALYZE语句对表字段分析后记录在这里 TBL_COL_PRIVS 表字段的授权信息 PART_PRIVS 分区的授权信息 PART_COL_PRIVS 分区字段的权限信息 PART_COL_STATS 分区字段的统计信息 FUNCS 用户注册的函数信息 FUNC_RU 用户注册函数的资源信息]]></content>
      <categories>
        <category>Hive</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Install pyhs2 for windows]]></title>
    <url>%2F2018%2F08%2F08%2Fenv%2Finstall-pyhs2-for-windows%2F</url>
    <content type="text"><![CDATA[在网站 pythonlibs 下载whl包 sasl-0.2.1-cp27-cp27m-win_amd64.whl pyhs2-0.6.0-py2.py3-none-any.whl 命令行安装12pip install sasl-0.2.1-cp27-cp27m-win_amd64.whlpip install pyhs2-0.6.0-py2.py3-none-any.whl 在安装时可能发生pip版本低,需升级pip1pip install --upgrade pip 由于pip 升级后版本中没有main(),使用PyCharm IDE环境安装其他包会发生错误 PyCharm安装目录\helpers\packaging_tool.py 在头部加上1import pip._internal as pip_new 然后分别修改文件中的这两行中的pip12return pip.main(['install'] + pkgs)return pip.main(['uninstall', '-y'] + pkgs) 为12return pip_new.main(['install'] + pkgs)return pip_new.main(['uninstall', '-y'] + pkgs)]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用selenium模拟浏览器获取网页数据]]></title>
    <url>%2F2017%2F12%2F30%2Fpython%2Fpython_use_selenium_demo%2F</url>
    <content type="text"><![CDATA[ChromeDriver资源chromedriver与chrome版本映射表 chromedriver下载地址 代码说明 通过百度搜索关键词，取出搜索结果 通过百度搜索图片 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127# -*- coding=utf-8 -*-import timeimport sysimport win32guiimport win32confrom selenium import webdriverreload(sys)sys.setdefaultencoding('utf-8')class ChromeDriver: def __init__(self, chrome_driver_path): self.chrome_driver = None self.chrome_driver_path = chrome_driver_path def start(self): print "启动chrome" # 启动chrome self.chrome_driver = webdriver.Chrome(self.chrome_driver_path) def stop(self): print "关闭chrome" # 关闭chrome if self.chrome_driver is not None: self.chrome_driver.quit() def open_web_page(self, url): print "打开网页 [%s]" % url # 模拟打开网页 self.chrome_driver.get(url) time.sleep(2) def search_pic_for_baidu(self, pic_path): """ 使用baidu查询图片数据 :param pic_path: :return: """ self.open_web_page("https://www.baidu.com/") # 1.打开上传对话框 self.chrome_driver.find_element_by_class_name("soutu-btn").click() time.sleep(1) self.chrome_driver.find_element_by_class_name("upload-pic").click() time.sleep(2) # 2.提交图片 dialog = win32gui.FindWindow('#32770', u'打开') comboBoxEx32 = win32gui.FindWindowEx(dialog, 0, 'ComboBoxEx32', None) comboBox = win32gui.FindWindowEx(comboBoxEx32, 0, 'ComboBox', None) # 上面三句依次寻找对象，直到找到输入框Edit对象的句柄 edit = win32gui.FindWindowEx(comboBox, 0, 'Edit', None) # 确定按钮Button button = win32gui.FindWindowEx(dialog, 0, 'Button', None) time.sleep(3) # 往输入框输入绝对地址 win32gui.SendMessage(edit, win32con.WM_SETTEXT, None, pic_path) # 按button win32gui.SendMessage(dialog, win32con.WM_COMMAND, 1, button) time.sleep(1) # 使用百度查找内容 def search_key_for_baidu(self, content, page_count): """ 使用baidu查找内容, 最多获取 page_count页 :param content: :param page_count: :return: """ self.chrome_driver.find_element_by_id("kw").clear() time.sleep(1) self.chrome_driver.find_element_by_id("kw").send_keys(content) self.chrome_driver.find_element_by_id("su").click() time.sleep(3) return self._get_key_search_data(page_count) # 获取搜索出的内容 def _get_key_search_data(self, page_count): # 打开页数 if page_count == 0: return result_list = self.chrome_driver.find_elements_by_class_name("result") for d in result_list: if d is not None: t = d.find_element_by_class_name("t") print t.text page = self.chrome_driver.find_element_by_id("page") if page is not None: _as = page.find_elements_by_tag_name("a") if len(_as) &gt; 0: _next_url = _as[-1].get_attribute("href") page_count -= 1 self.open_web_page(_next_url) else: page_count = 0 # 递归调用 self._get_key_search_data(page_count)if __name__ == '__main__': driver_path = "chrome_driver路径" cd = ChromeDriver(driver_path) cd.start() # 使用baidu搜索关键词 cd.open_web_page("https://www.baidu.com/") cd.search_key_for_baidu("python", 2) # 使用baidu搜索图片 cd.search_pic_for_baidu("图片路径") # 休眠 time.sleep(10) cd.stop()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Python实现Excel文件的读写]]></title>
    <url>%2F2017%2F12%2F23%2Fpython%2Fpython_write_excel%2F</url>
    <content type="text"><![CDATA[使用xlwt和xlrd来操作excel xlwt库用于写excel文件 xlrd库用于读excel文件 Demo代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899# coding=utf8import xlwtimport xlrdclass ExcelWrite: def __init__(self): # 创建workbook和sheet对象 self.workbook = xlwt.Workbook() # 构建一个sheet页 (cell_overwrite_ok: true-&gt;单元格内容被覆盖) self.sheet = self.workbook.add_sheet(u"Sheet名字", cell_overwrite_ok=True) # 写入自定义的标题内容 self._write_title() # 保存文件 def save(self, file_name): self.workbook.save(file_name) # 写入内容 def write_text(self, row_data_list): """ 写入数据 :param row_data_list: 准备写入excel文件的数据(定义了一个二维数组结构) :return: """ # 从第2行开始, 第一行为标题行 for i in range(0, len(row_data_list)): self._write_row_text(i+1, row_data_list[i]) # 写入行内容 def _write_row_text(self, row_index, col_data_list): """ 写数据到指定行中 :param list_data: 对应行中每一列的数据 :return: """ for i in range(0, len(col_data_list)): self.sheet.write(row_index, i, col_data_list[i]) # 写入标题 def _write_title(self): title_list = [u"列1", u"列2", u"列3"] for i in range(0, len(title_list)): self.sheet.write(0, i, title_list[i])class ExcelRead: def __init__(self): pass def read_excel(self, file_name): # 打开excel文件 data = xlrd.open_workbook(file_name) # 获取sheet标签 table = data.sheet_by_name("Sheet名字") # sheet标签中的行数 rows = table.nrows # sheet标签中的列数 cols = table.ncols # 获取每行的数据 for i in range(0, rows): print(table.row_values(i)) # 获取每列的数据 for x in range(0, cols): print(table.col_values(x)) # # # 逐个获取单元格数据 for i in range(0, rows): for j in range(cols): print(table.cell(i, j).value)if __name__ == '__main__': eo = ExcelWrite() col_list = ["aaa", "bbb", "ccc"] col_list1 = ["aaa111", "bbb111", "ccc111"] col_list2 = ["aaa222", "bbb222", "ccc222"] data_list = list() data_list.append(col_list) data_list.append(col_list1) data_list.append(col_list2) # 写入数据 eo.write_text(data_list) # 保存文件 eo.save("111.xls") # 读取文件 er = ExcelRead() er.read_excel("111.xls")]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Python实现发送带附件的邮件]]></title>
    <url>%2F2017%2F12%2F16%2Fpython%2Fpython_send_email%2F</url>
    <content type="text"><![CDATA[使用smtplib和email库发送邮件 使用smtplib库来发送邮件 使用Email库来处理邮件消息 Demo代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/python# -*- coding: UTF-8 -*-import smtplibfrom email.mime.text import MIMETextfrom email.mime.multipart import MIMEMultipartfrom email.header import Headerimport loggingclass EMailOpr: def __init__(self): self.sender = '发送者邮箱' self.receivers = ['接受者邮箱1', "接受者邮箱2"] self.cc = ['抄送1', '抄送2'] self.hide = ["暗抄1", "暗抄2"] self.smtp = 'smtp.****.com' self.smtp_port = 25 self.user = "发送者账号" self.passwd = "发送者密码" # 发送邮件 def send(self, subject, content="", att_path=""): """ 发送邮件 :param subject: 邮件主题 :param content: 邮件内容 :param att_path: 邮件附件地址 :return: """ # 创建一个带附件的实例 message = MIMEMultipart() message['From'] = self.sender message['To'] = ",".join(self.receivers) message['Cc'] = ",".join(self.cc) message['Subject'] = Header(subject, 'utf-8') # 邮件正文内容 message.attach(MIMEText(content, 'plain', 'utf-8')) # 添加附件 if att_path != "": # 构造附件1 att1 = MIMEText(open(att_path, 'rb').read(), 'base64', 'utf-8') att1["Content-Type"] = 'application/octet-stream' # 这里的filename可以任意写，写什么名字，邮件中显示什么名字 att1["Content-Disposition"] = 'attachment; filename=%s' % att_path[att_path.rfind("/")+1:] message.attach(att1) try: smtpObj = smtplib.SMTP() smtpObj.connect(self.smtp, self.smtp_port) smtpObj.login(self.user, self.passwd) smtpObj.sendmail(self.sender, self.receivers+self.cc+self.hide, message.as_string()) print u"邮件发送成功" except smtplib.SMTPException: print u"Error: 无法发送邮件"if __name__ == '__main__': file_name = "附件文件路径" email = EMailOpr() email.send("主题", "内容", file_name)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>email</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用over()函数结合PARTITION BY以指定字段分区]]></title>
    <url>%2F2017%2F12%2F06%2Fhive%2Fhive_over_partition_by_demo%2F</url>
    <content type="text"><![CDATA[over()函数和PARTITION BY结合使用123456789101112SELECT item_id, item_nameFROM (SELECT item_id, item_name, sort_item, row_number () over (PARTITION BY item_id ORDER BY sort_item DESC) AS rm FROM table_name) AS tWHERE t.rm = 1 以item_id分区，所有item_id相同的被放入一个分区中 分区内使用row_number()对每一行做标识 根据sort_item字段进行排序 获取每个分区中的第一数据]]></content>
      <categories>
        <category>Hive</category>
      </categories>
      <tags>
        <tag>hive</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hive列转行]]></title>
    <url>%2F2017%2F12%2F05%2Fhive%2Fhive_col_transfer_line%2F</url>
    <content type="text"><![CDATA[列转行hive中由多行数据转换成一行记录 test表数据：1234567891011id name-- -----1 aaa1 bbb1 ccc1 ddd1 eee1 fff1 ggg1 hhh1 iii 使用collect_set()函数聚合id相同的name1select id, collect_set(name) from test group by id; 结果为： 11 [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;ddd&quot;,&quot;eee&quot;,&quot;fff&quot;,&quot;ggg&quot;,&quot;hhh&quot;,&quot;iii&quot;] 结合concat_ws()函数拼接成字符串1select id, concat_ws(&quot;,&quot;, collect_set(name)) from test group by id; 结果为： 11 aaa,bbb,ccc,ddd,eee,fff,ggg,hhh,iii]]></content>
      <categories>
        <category>Hive</category>
      </categories>
      <tags>
        <tag>hive</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spark subtract 算子的应用]]></title>
    <url>%2F2017%2F12%2F03%2Fspark%2Fspark_subtract_demo%2F</url>
    <content type="text"><![CDATA[问题引入有两个集合A和B A集合存放历史数据 B集合存放当前计算出的数据 现在需要把存在于历史数据集合中，但不存在当前计算集合中的数据标出，并且同集合B，组成新的集合C 相对补集(差集)若A和B是集合，则A在B中的相对补集是这样一个集合：其元素属于B但不属于A，B - A = { x| x∈B且x∉A}。 subtract() 算子spark 算子 subtract() 正好实现了我们以上需求。 A.subtract(B) 返回在A中出现, 并且不在B中出现的元素 123456val A_rdd = sc.makeRDD(Seq(1,2,2,3))val B_rdd = sc.makeRDD(Sel(3, 4))val AB_diff_rdd = A_rdd.subtract(B_rdd)val C_rdd = B_rdd.union(AB_diff_rdd)]]></content>
      <categories>
        <category>Spark</category>
      </categories>
      <tags>
        <tag>spark</tag>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Sqoop同步 mysql hive 数据]]></title>
    <url>%2F2017%2F12%2F01%2Fsqoop%2Fsqoop_hive_to_mysql%2F</url>
    <content type="text"><![CDATA[hive 到 mysql 同步12345678910sqoop export --connect jdbc:mysql://[ip]:[port]/db_name?characterEncoding=utf-8 --username name --password passwd --table table_name --input-fields-terminated-by &quot;\t&quot; (hive表中字段之间使用的分割符) --input-lines-terminated-by &quot;\n&quot; (hive表中行与行之间使用的分隔符) --export-dir [hdfs存储位置] (通过 show create table table_name可以查看) --update-key key_id (mysql表中对应的主键) --update-mode allowinsert (更新模式[allowinsert, updateonly]) mysql 到 hive 同步123456789101112sqoop import --connect jdbc:mysql://[ip]:[port]/db_name --username username --password passwd --table srcMysqltableName --fields-terminated-by &quot;\t&quot; (构建后hive表中的字段分隔符) --hive-drop-import-delims (去掉hive默认的行分隔符&quot;\n&quot;) --hive-import (导入数据到hive) --hive-overwrite --create-hive-table --hive-table destHivetableName --delete-target-dir]]></content>
      <categories>
        <category>Hive</category>
        <category>Sqoop</category>
      </categories>
      <tags>
        <tag>hive</tag>
        <tag>sqoop</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hive行转列]]></title>
    <url>%2F2017%2F11%2F29%2Fhive%2Fhive_line_transfer_col%2F</url>
    <content type="text"><![CDATA[行转列把Hive中，一行的数据转换成多条数据 test表数据：123456789a aaab bbbc cccd ddde eeef fffg gggh hhhi iii 构建使用分隔符分割 (“,”) 的数据1SELECT CONCAT_WS(',', '1', '2', '3', '4', '5', '6', '7', '8', '9') FROM test; 数据为：11,2,3,4,5,6,7,8,9 使用分割函数 split1SELECT split(CONCAT_WS(',', '1', '2', '3', '4', '5', '6', '7', '8', '9'), ",") FROM test; 数据为:1[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;] 使用行专列函数 explode1select explode(split(concat_ws(',', '1', '2', '3', '4', '5', '6', '7', '8', '9'), ',')) from test; 数据为:123456789123456789 使用lateral view 把其他字段显示出来1select a.*, b from test a lateral view explode(split(concat_ws(',', '1', '2', '3', '4', '5', '6', '7', '8', '9'), ',')) t as b; 数据为：12345678910111213141516171819a aaa 1a aaa 2a aaa 3a aaa 4a aaa 5a aaa 6a aaa 7a aaa 8a aaa 9b bbb 1b bbb 2b bbb 3b bbb 4b bbb 5b bbb 6b bbb 7b bbb 8b bbb 9…………]]></content>
      <categories>
        <category>Hive</category>
      </categories>
      <tags>
        <tag>hive</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过shell脚本实现交互式客户端的输入]]></title>
    <url>%2F2017%2F10%2F21%2Fshell%2Fshell_client_run_cmd%2F</url>
    <content type="text"><![CDATA[需求 在不进入交互式模式下, 执行交互式下的命令 脚本模板123命令 &lt;&lt;EOF交互语句EOF Mysql使用例子12345678910111213141516171819mysql -uroot -hlocalhost -proot &lt;&lt;EOFcreate database if not exists test;use test;create table if not exists test( id int(2), name varchar(10));insert into test(id, name) values(1, &quot;aaa&quot;);insert into test(id, name) values(2, &quot;bbb&quot;);insert into test(id, name) values(3, &quot;ccc&quot;);insert into test(id, name) values(4, &quot;ddd&quot;);insert into test(id, name) values(5, &quot;fff&quot;);select id, name from test;EOF]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>client</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CFileDialog路径缓存的扩充]]></title>
    <url>%2F2017%2F03%2F25%2Fc%2B%2B%2FCFileDialog_multiple_select%2F</url>
    <content type="text"><![CDATA[问题描述CFileDialog开启多选后，能够选中的文件个数有限。 问题原因CFileDialog中默认的Buffer空间不足以存放所选中的文件路径字符串集合，所以字符串内容会被截断，保存的信息不够完整。 对话框中，在选中文件后，会有一个Buffer来保存所有选中文件的字符串，还有一个变量保存Buffer的长度。这些信息都保存在OPENFILENAME结构中。缓存首地址： m_ofn.lpstrFile缓存长度：m_ofn.nMaxFile 解决方案 每次申请足够大的缓存来存放路径字符串 根据选中的内容，动态计算路径字符串的长度，大于默认值后，再手动申请缓存空间 方案1 – 定长缓存1234567891011121314151617181920212223242526const int M = 1024 * 1024;//构建对话框CFileDialog dlgFile(TRUE, NULL, NULL,OFN_ALLOWMULTISELECT | OFN_HIDEREADONLY | OFN_NODEREFERENCELINKS | OFN_EXPLORER, szFilter, NULL, 0, FALSE); //定义缓存大小，临时区域int nMax = 10 * M;fileDlg.m_ofn.nMaxFile = nMax;fileDlg.m_ofn.lpstrFile = new TCHAR[nMax];//处理路径if (fd.DoModal() == IDOK) &#123; POSITION pos = fileDlg.GetStartPosition(); while (pos != NULL) &#123; CString path = fileDlg.GetNextPathName(pos); //DoSomething &#125;&#125;//释放资源if (fileDlg.m_ofn.lpstrFile != NULL) &#123; delete[] fileDlg.m_ofn.lpstrFile; fileDlg.m_ofn.lpstrFile = NULL;&#125; 方案2 – 动态缓存使用时，Win7以上系统，构造函数参数 bVistaStyle 赋值为FALSE。 1234CMutipleSelFileDialog dlgFile(TRUE, NULL, NULL, OFN_ALLOWMULTISELECT | OFN_HIDEREADONLY| OFN_NODEREFERENCELINKS | OFN_EXPLORER, szFilter, NULL, 0, FALSE); 头文件1234567891011121314151617181920212223242526272829303132333435363738394041#ifndef _MULTIPLE_SEL_FILE_DIALOG_H_#define _MULTIPLE_SEL_FILE_DIALOG_H_#include &lt;string&gt;using std::string;class CMutipleSelFileDialog : public CFileDialog &#123; DECLARE_DYNAMIC(CMutipleSelFileDialog)public: CMutipleSelFileDialog(BOOL bOpenFileDialog, // TRUE for FileOpen, FALSE for FileSaveAs LPCTSTR lpszDefExt = NULL, LPCTSTR lpszFileName = NULL, DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT, LPCTSTR lpszFilter = NULL, CWnd* pParentWnd = NULL, DWORD dwSize = 0, BOOL bVistaStyle = TRUE ); virtual ~CMutipleSelFileDialog();public: virtual int DoModal(); CString GetNextPathName(POSITION&amp; pos) const; POSITION GetStartPosition(); void SetTitleName(const string&amp; name); DECLARE_MESSAGE_MAP()private: virtual void OnFileNameChange(); //BOOL IsWin7_or_Later(); void Release();private: bool m_bParsed; TCHAR* m_pFolder; TCHAR* m_pFiles;&#125;;#endif //_MULTIPLE_SEL_FILE_DIALOG_H_ 实现文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include "stdafx.h"#include "MultipleSelFileDialog.h"#include &lt;cderr.h&gt;#ifdef _DEBUG#define new DEBUG_NEW#undef THIS_FILEstatic char THIS_FILE[] = __FILE__;#endifIMPLEMENT_DYNAMIC(CMutipleSelFileDialog, CFileDialog)BEGIN_MESSAGE_MAP(CMutipleSelFileDialog, CFileDialog)//&#123;&#123;AFX_MSG_MAP(CFECFileDialog)//&#125;&#125;AFX_MSG_MAPEND_MESSAGE_MAP()CMutipleSelFileDialog::CMutipleSelFileDialog(BOOL bOpenFileDialog, LPCTSTR lpszDefExt, LPCTSTR lpszFileName, DWORD dwFlags, LPCTSTR lpszFilter, CWnd* pParentWnd, DWORD dwSize, BOOL bVistaStyle): CFileDialog(bOpenFileDialog, lpszDefExt, lpszFileName, dwFlags, lpszFilter, pParentWnd, dwSize, bVistaStyle)&#123; m_pFiles = NULL; m_pFolder = NULL; m_bParsed = false;&#125;CMutipleSelFileDialog::~CMutipleSelFileDialog()&#123; Release(); if (m_ofn.lpstrTitle != NULL) &#123; delete[] m_ofn.lpstrTitle; m_ofn.lpstrTitle = NULL; &#125;&#125;int CMutipleSelFileDialog::DoModal()&#123; Release(); int ret = CFileDialog::DoModal(); if (ret == IDCANCEL) &#123; DWORD err = CommDlgExtendedError(); if (err == FNERR_BUFFERTOOSMALL/*0x3003*/ &amp;&amp; m_pFiles != NULL) &#123; ret = IDOK; &#125; &#125; return ret;&#125;CString CMutipleSelFileDialog::GetNextPathName(POSITION&amp; pos) const&#123; if (m_pFiles == NULL) &#123; return CFileDialog::GetNextPathName(pos); &#125; ASSERT(pos); TCHAR *ptr = (TCHAR *)pos; CString ret = m_pFolder; ret += _T("\\"); ret += ptr; ptr += _tcslen(ptr) + 1; if (*ptr) &#123; pos = (POSITION)ptr; &#125; else &#123; pos = NULL; &#125; return ret;&#125;POSITION CMutipleSelFileDialog::GetStartPosition()&#123; if (m_pFiles == NULL) &#123; return CFileDialog::GetStartPosition(); &#125; if (!m_bParsed) &#123; CString temp = m_pFiles; temp.Replace(_T("\" \""), _T("\"")); temp.Delete(0, 1); // remove leading quote mark temp.Delete(temp.GetLength() - 1, 1); // remove trailing space _tcscpy(m_pFiles, temp); TCHAR *ptr = m_pFiles; while (*ptr) &#123; if ('\"' == *ptr) &#123; *ptr = '\0'; &#125; ++ptr; &#125; m_bParsed = TRUE; &#125; return (POSITION)m_pFiles;&#125;void CMutipleSelFileDialog::SetTitleName(const string&amp; name)&#123; if (m_ofn.lpstrTitle != NULL) &#123; delete[] m_ofn.lpstrTitle; m_ofn.lpstrTitle = NULL; &#125; int nLen = name.size() + 1; char* pBuf = new char[nLen]; memset(pBuf, 0, nLen); memcpy(pBuf, name.c_str(), nLen); m_ofn.lpstrTitle = pBuf;&#125;void CMutipleSelFileDialog::OnFileNameChange()&#123; TCHAR dummy_buffer; //Win7以上，构造函数参数 bVistaStyle 赋值为flase，否则GetParent()为NULL //导致无消息接受窗口，无法获取以下信息 HWND hWnd = GetParent() == NULL ? m_hWnd : GetParent()-&gt;m_hWnd; // 所有选中文件名集合的的长度.如：("xxx1.dat" "xxx2.dat") // 每一个文件名包含在双引号中，文件名之间有空格符 int nfiles = CommDlg_OpenSave_GetSpec(hWnd, &amp;dummy_buffer, 1); // 去除文件名，文件目录的长度.如：("x:\xxx\xxx\") int nfolder = CommDlg_OpenSave_GetFolderPath(hWnd, &amp;dummy_buffer, 1); // 选中内容长度超过了默认的缓存区长度 if (nfiles + nfolder &gt; m_ofn.nMaxFile) &#123; m_bParsed = FALSE; Release(); m_pFiles = new TCHAR[nfiles + 1]; CommDlg_OpenSave_GetSpec(hWnd, m_pFiles, nfiles); m_pFolder = new TCHAR[nfolder + 1]; CommDlg_OpenSave_GetFolderPath(hWnd, m_pFolder, nfolder); &#125; else if (m_pFiles != NULL) &#123; Release(); &#125; CFileDialog::OnFileNameChange();&#125;void CMutipleSelFileDialog::Release()&#123; if (m_pFiles != NULL) &#123; delete[] m_pFiles; m_pFiles = NULL; &#125; if (m_pFolder != NULL) &#123; delete[] m_pFolder; m_pFolder = NULL; &#125;&#125;]]></content>
      <categories>
        <category>C++</category>
        <category>MFC</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>windows</tag>
        <tag>mfc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一种解决指针无效引用的方法]]></title>
    <url>%2F2017%2F03%2F04%2Fc%2B%2B%2Fweak_pointer_used%2F</url>
    <content type="text"><![CDATA[无效引用 当多个指针指向同一个对象，在其中一个指针被delete后 其他指向该对象的指针不知道，其指向的内存已经无效 当访问指针指向的数据时出现访问错误。 项目优化的需求 避免项目中无效引用的使用 在尽量少的变更代码的条件下能够实现该优化 不影响正常的逻辑 解决方案我们通过对被管理对象加标签，以及使用弱指针来代替旧的指针的方式来实现。 标签可以把标签理解成一个书签。在对象创建时，对象中带有一个没有写任何内容的空白书签，在对象指针赋值给弱指针时，会在书签中填充内容，内容为对象的指针，并在弱指针中保存书签指针。 被管理对象通过继承标签指针来具备书签功能。 弱指针在说弱指针之前，先描述下我们定义的强指针，只要强指针存在，其指向的内容一定存在。 这里的弱指针相对于强指针，弱指针存在，其指向的内容可以不存在。既在弱指针指向的内存被释放，我们能够及时知道当前指针已经无效。 把对指针的所有操作封装到弱指针类中，让其能够模拟指针，这样可以在旧代码不变动的条件下，也就是说使用者可以完全不知道弱指针的存在，任然像正常指针一样使用。 利用弱指针的这种特性，我们正好能够解决无效引用带来的问题，并且能够满足优化提到的三点需求。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324#ifndef _WEAK_TAG_POINTER_H_#define _WEAK_TAG_POINTER_H_#include &lt;stdio.h&gt;#include &lt;assert.h&gt;template&lt;typename T&gt; class WeakPointer;template&lt;typename T&gt;class WeakTagPointer &#123;private: /** * @desc 标签 1. 被标识类继承标签指针 * 2. 当被标识类构建对象时，标签指针中引用计数默认为1 * 3. 只有当被标识对象释放，标签中的pinter指针会被置为NULL * 4. 当标签的引用计数为0时，会释放标签自身 */ struct WeakTag &#123; WeakTag(T* p): pointer(p), count(1) &#123; &#125; /** * @desc 减少引用计数，没有被引用释放自身 */ void WeakRelease() &#123; --count; if (count &lt;= 0) &#123; delete this; &#125; &#125; /** * @desc 增加引用计数 */ void WeakAddRef() &#123; ++count; &#125; /** * @desc 获取标签指针 */ T* Pointer() const &#123; return pointer; &#125; /** * @desc 设置标签指针 */ void SetPointer(T* pObj) &#123; pointer = pObj; &#125; private: T* pointer; //标签指针 int count; //引用计数 &#125;;public: WeakTagPointer() : m_pWeakTag(NULL) &#123;&#125; /** * @desc 当子类(及被标识对象)析构时, 触发父类析构。 * 1. 被标识对象释放，pointer标识被置NULL * 2. 通知其他使用者，该指针已无效 */ virtual ~WeakTagPointer() &#123; if (m_pWeakTag != NULL) &#123; m_pWeakTag-&gt;SetPointer(NULL); m_pWeakTag-&gt;WeakRelease(); &#125; &#125;public: /** * @desc 获取标签指针 * 1. 指针未空时创建并返回, this指针为被标识对象 * 2. 每次调用该函数，引用计数加1 */ WeakTag* TagPointer() &#123; if (m_pWeakTag == NULL) &#123; m_pWeakTag = new WeakTag(static_cast&lt;T*&gt;(this)); &#125; if (m_pWeakTag != NULL) &#123; m_pWeakTag-&gt;WeakAddRef(); &#125; return m_pWeakTag; &#125;private: template&lt;typename T2&gt; friend class WeakPointer; WeakTag* m_pWeakTag;&#125;;///////////////////////////////////////////////////////////////////////////** * WeakPointer类，模拟指针的各种操作 */template&lt;typename T&gt;class WeakPointer &#123; //typedef typename T::WeakTag WeakTagType; struct WeakTagType : public T::WeakTag &#123;&#125;;public: WeakPointer():m_pTag(NULL) &#123;&#125; ~WeakPointer() &#123; Release(); &#125;public: /** * @desc 获取标签指针 */ T* operator-&gt;() &#123; return GetPointer(); &#125; /** * @desc 获取指针对应的引用数据 */ T&amp; operator*() &#123; T* p = GetPointer(); assert(p != NULL); return *p; &#125; /** * @desc bool重载 */ operator bool() &#123; return IsValid(); &#125; ////////////////////////////////////////////////////////////////////////// //等于 ////////////////////////////////////////////////////////////////////////// /** * @desc 对指定类型指针赋值 */ void operator=(T* pObj) &#123; WeakTagType* pTag = NULL; if (pObj != NULL) &#123; //获取对象中标识 WeakTagType* pTag = static_cast&lt;WeakTagType*&gt;(pObj-&gt;TagPointer()); if (pTag != NULL) &#123; //释放自身标识数据 Release(); &#125; &#125; //赋值 m_pTag = pTag; &#125; /** * @desc 同类型pointer的赋值 * @param [in] pObj 同类型弱指针 */ WeakPointer&amp; operator=(WeakPointer&amp; obj) &#123; if (this != &amp;obj) &#123; operator=(obj.GetPointer()); &#125; return *this; &#125; /** * @desc 不同类型pointer的赋值 * @param [in] pObj 其他类型弱指针 */ template&lt;typename T2&gt; void operator=(WeakPointer&lt;T2&gt;&amp; obj) &#123; operator=(obj.GetPointer()); &#125; ////////////////////////////////////////////////////////////////////////// //等于等于 ////////////////////////////////////////////////////////////////////////// /** * @desc 判断同类型弱指针是否相同 */ bool operator==(WeakPointer&amp; obj) &#123; return IsEqual(obj); &#125; /** * @desc 判断和表示类型的指针是否相同 */ bool operator==(T* pObj) &#123; return IsEqual(pObj); &#125; /** * @desc 判断和表示类型的指针是否相同, 特例NULL */ bool operator==(const int&amp;) &#123; return !IsValid(); &#125; /** * @desc 判断和其他类型的弱指针是否不同 */ template&lt;typename T2&gt; bool operator==(WeakPointer&lt;T2&gt;&amp; obj) &#123; return IsEqual(obj); &#125; ////////////////////////////////////////////////////////////////////////// //不等于 ////////////////////////////////////////////////////////////////////////// /** * @desc 判断同类型弱指针是否不同 */ bool operator!=(WeakPointer&amp; obj) &#123; return !IsEqual(obj); &#125; /** * @desc 判断和指针是否不同, 特例NULL */ bool operator!=(const int&amp;) &#123; return IsValid(); &#125; /** * @desc 判断和表示类型的指针是否不同 */ bool operator!=(T* pObj) &#123; return !IsEqual(pObj); &#125; ////////////////////////////////////////////////////////////////////////// // ////////////////////////////////////////////////////////////////////////// /** * @desc 获取标签指针 */ T* GetPointer() &#123; T* p = NULL; if (m_pTag != NULL) &#123; p = static_cast&lt;T*&gt;(m_pTag-&gt;Pointer()); &#125; return p; &#125; /** * @desc 判断标签的有效性 * @return 是否有效 */ bool IsValid() const &#123; return (m_pTag != NULL) &amp;&amp; (m_pTag-&gt;Pointer() != NULL); &#125;private: WeakPointer(const WeakPointer&amp;); /** * @desc 判断两个同类型弱指针是否相同 */ bool IsEqual(WeakPointer&amp; obj) &#123; return IsEqual(obj.m_pTag, obj.GetPointer()); &#125; /** * @desc 判断两个弱指针是否相同 */ template&lt;typename T2&gt; bool IsEqual(WeakPointer&lt;T2&gt;&amp; obj) &#123; return false; &#125; bool IsEqual(WeakTagType* pTag, T* pObj) &#123; bool b = false; if (m_pTag == NULL &amp;&amp; pTag == NULL) &#123; b = true; &#125; else if (m_pTag != NULL &amp;&amp; pTag != NULL) &#123; bool b0 = (m_pTag == pTag); bool b1 = (m_pTag-&gt;Pointer() == pObj); b = (b0 &amp;&amp; b1); &#125; return b; &#125; // bool IsEqual(T* pObj) &#123; bool b = false; if (m_pTag != NULL &amp;&amp; pObj != NULL) &#123; b = (m_pTag-&gt;Pointer() == pObj); &#125; return b; &#125; /** * 释放标签数据 */ void Release() &#123; if (m_pTag != NULL) &#123; m_pTag-&gt;WeakRelease(); &#125; &#125;private: template&lt;typename T2&gt; friend class WeakPointer; WeakTagType* m_pTag;&#125;;#endif //_WEAK_TAG_POINTER_H_ 完整测试代码]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>template</tag>
        <tag>弱指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows剪切板项目中遇到的问题]]></title>
    <url>%2F2017%2F02%2F20%2Fc%2B%2B%2Fclipboard_use%2F</url>
    <content type="text"><![CDATA[操作描述复制word内容，word会把多种类型数据写入剪切板中，我们获取的是剪切板中RTF类型的数据。 问题使用系统函数获取剪切板数据。 123456789101112131415if (OpenClipboard(NULL)) &#123; UINT cfRTF = RegisterClipboardFormat(CF_RTF); if (IsClipboardFormatAvailable(cfRTF)) &#123; HANDLE hRtfData = GetClipboardData(cfRTF); if (hRtfData != NULL) &#123; //pBuf为剪切板中获取的RTF数据 char* pBuf = (char*)GlobalLock(hRtfData); GlobalUnlock(hRtfData); &#125; &#125; CloseClipboard();&#125; 以上代码在两台机器上的表现不同: 机器1：调用GetClipboardData()函数，返回NULL,GetLastError()返回1418 机器2：出现两种不同的情况 调用GetClipboardData()函数，返回NULL,GetLastError()返回1460 调用GetClipboardData()函数，返回正确的数据句柄 1. ERROR_CLIPBOARD_NOT_OPEN (1418) 错误信息提示没有打开剪切板，但是可以看出代码中，打开了剪切板并判断了其中是否包含RTF数据，但是就是在以上两个函数都执行成功的前提下，调用GetClipboardData()返回NULL。 带着以上问题在网上查找相关资料，偶然发现有人说加断点的原因（由于获取剪切板数据错误，我在OpenClipboard(NULL)处加了断点），去掉断点后仍然返回NULL，但是错误码变成了1460，这样两个问题合并成了一个问题。 其实在机器2上我也添加了断点，但是没有出现1418的错误，直接返回的是1460的错误，这里我判断可能是和机器相关，没有继续深入的调查。 2. ERROR_TIMEOUT (1460)在分析这个问题前，先说下我在网上找的剪切板的的一种机制：延迟提交 延迟提交，只需剪贴板拥有者进程在调用SetClipboardData()将数据句柄（第二个参数）设置为NULL即可。 延迟提交的拥有者进程需要做的主要工作是对WM_RENDERFORMAT、WM_DESTORYCLIPBOARD和WM_RENDERALLFORMATS等剪贴板延迟提交消息的处理。 当其他进程调用GetClipboardData()函数时，系统将会向延迟提交数据的剪贴板拥有者进程发送WM_RENDERFORMAT消息。 剪贴板拥有者进程在此消息的响应函数中应使用相应的格式和实际的数据句柄来调用SetClipboardData()函数，但无需再调用OpenClipboard()和EmptyClipboard()去打开和清空剪贴板了，在设置完数据也无须调用CloseClipboard()关闭剪贴板。 如果其他进程打开了剪贴板并且调用EmptyClipboard()函数去清空剪贴板的内容，接管剪贴板的拥有权时，系统将向延迟提交的剪贴板拥有者进程发送WM_DESTROYCLIPBOARD消息， 以通知该进程对剪贴板拥有权的丧失。而失去剪贴板拥有权的进程在收到该消息后则不会再向剪贴板提交数据。 另外，在延迟提交进程在提交完所有要提交的数据后也会收到此消息。 如果延迟提交剪贴板拥有者进程将要终止，系统将会为其发送一条WM_RENDERALLFORMATS消息，在响应函数中可自定义是否调用SetClipboardData()来设置数据。 Word在把数据放到剪切板中时使用了延迟提交技术。在我们编写的程序中调用GetClipboardData()，触发了word的WM_RENDERFORMAT消息，word把数据处理并写到剪切板中，最后返回给调用者。 在word设置数据到剪切板，再到返回给调用者，中间使用的时间过长会出现ERROR_TIMEOUT错误 分析结果： 由于机器配置不同，处理速度各异，机器配置好的处理速度快的，在系统设置的响应时间内，能完成数据设置到剪切板的，就能够正确的获取剪切板数据。 根据推测系统调用GetClipboardData()的响应时间有可能是可以设置的，目前在网络上还没有找到相应的设置方法。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>windows</tag>
        <tag>剪切板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下zlib库的使用]]></title>
    <url>%2F2017%2F02%2F15%2Fc%2B%2B%2Fzlib_use%2F</url>
    <content type="text"><![CDATA[下载zlib库zlib-1.2.10.tar.gz 编译解压后 zlib-1.2.10/win32/Makefile.msc 文件中介绍了如何编译： Makefile for zlib using Microsoft (Visual) Czlib is copyright (C) 1995-2006 Jean-loup Gailly and Mark AdlerUsage:nmake -f win32/Makefile.msc (standard build)nmake -f win32/Makefile.msc LOC=-DFOO (nonstandard build)nmake -f win32/Makefile.msc LOC=”-DASMV -DASMINF” \OBJA=”inffas32.obj match686.obj” (use ASM code, x86)nmake -f win32/Makefile.msc AS=ml64 LOC=”-DASMV -DASMINF -I.” \OBJA=”inffasx64.obj gvmat64.obj inffas8664.obj” (use ASM code, x64) 运行 Visual Studio Tools/Visual Studio 2008 Command Prompt命令控制行12# cd 解压目录# nmake -f win32/Makefile.msc 库的使用只使用zlib库的话把下图中头文件放到工程路径下，包含zlib.h头文件，即可使用。 压缩/解压数据 123456789101112131415161718192021222324252627282930313233#include "zlib/zlib.h"void Test1();int _tmain(int argc, _TCHAR* argv[]) &#123; Test1(); getchar();&#125;void Test1()&#123; /* 原始数据 */ unsigned char strSrc[] = "hello world! 中文"; unsigned char buf[1024] = &#123;0&#125;; unsigned char strDst[1024] = &#123;0&#125;; unsigned long srcLen = sizeof(strSrc); unsigned long bufLen = sizeof(buf); unsigned long dstLen = sizeof(strDst); printf("Src string:%s\nLength:%ld\n", strSrc, srcLen); /* 压缩 */ compress(buf, &amp;bufLen, strSrc, srcLen); printf("After Compressed Length:%ld\n", bufLen); /* 解压缩 */ uncompress(strDst, &amp;dstLen, buf, bufLen); printf("After UnCompressed Length:%ld\n",dstLen); printf("UnCompressed String:%s\n",strDst);&#125; 使用minizip(压缩包)再额外包含zlib-1.2.10\contrib目录下文件到工程路径中 并在项目中添加下图头文件和实现文件 在压缩包中创建文件并写入内容1234567891011121314151617181920212223242526272829303132333435363738394041424344#include "zlib/zip.h"void Test3(const char* path);int _tmain(int argc, _TCHAR* argv[]) &#123; Test3(); getchar();&#125;void Test3(const char* path)&#123; zipFile zf = zipOpen64(path, APPEND_STATUS_CREATE); if (zf == NULL) &#123; printf("创建%s失败\n", path); return; &#125; //初始化写入zip的文件信息 zip_fileinfo zi; zi.tmz_date.tm_sec = zi.tmz_date.tm_min = zi.tmz_date.tm_hour = zi.tmz_date.tm_mday = zi.tmz_date.tm_mon = zi.tmz_date.tm_year = 0; zi.dosDate = 0; zi.internal_fa = 0; zi.external_fa = 0; //1 zipOpenNewFileInZip(zf, "t\\t.txt", &amp;zi, NULL, 0, NULL, 0, NULL, Z_DEFLATED, Z_DEFAULT_COMPRESSION); char* buf = "Hello_1111"; zipWriteInFileInZip(zf, buf, strlen(buf)); //关闭zip文件 zipCloseFileInZip(zf); //2 zipOpenNewFileInZip(zf, "t1\\t.txt", &amp;zi, NULL, 0, NULL, 0, NULL, Z_DEFLATED, Z_DEFAULT_COMPRESSION); zipWriteInFileInZip(zf, buf, strlen(buf)); //关闭zip文件 zipCloseFileInZip(zf); zipClose(zf, NULL);&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>windows</tag>
        <tag>zlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 使用 libtiff]]></title>
    <url>%2F2016%2F10%2F12%2Fc%2B%2B%2Flibtiff_win_demo%2F</url>
    <content type="text"><![CDATA[准备工作 下载 tiff-4.0.6 解压 [工作目录]/tiff/tiff-4.0.6 编译 libtiff 启动 VS Tools 中命令行工具 进入工作路径 cd /d [解压路径] 执行编译命令 nmake /f makefile.vc 提取头文件和库文件 在任意路径，新建目录 libdiff, 在libdiff中新建include 和 lib 拷贝 [解压路径]/libtiff/[libtiff.dll, libtiff.lib, libtiff_i.lib] 到 lib 目录中 拷贝 解压路径/libtiff/[tif_config.h, tif_dir.h, tiff.h, tiffconf.h, tiffio.h, tiffiop.h, tiffvers.h, uvcode.h] 到 include 目录中 编写 Demo VS 中创建工程，把上一步创建的目录拷贝到新创建的工程中 添加 include 到VC++目录-&gt;包含目录, 添加 lib 到VC++目录-&gt;库目录 添加 libtiff.lib 和 libtiff_i.lib 到linker-&gt;输入-&gt;附加依赖项中 12345678910111213141516171819#include &lt;stdlib.h&gt;#include "tiffio.h"int _tmain(int argc, _TCHAR* argv[])&#123; TIFF* tiff = NULL; int width, height; tiff = TIFFOpen("1.tif","r"); if(tiff !=NULL) &#123; TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &amp;width); TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &amp;height); printf("宽度：%d, 高度：%d\n", width, height); &#125; system("pause"); return 0;&#125; 问题 连接时出现： LINK : warning LNK4098: 默认库“MSVCRT”与其他库的使用冲突；请使用 /NODEFAULTLIB:library 解决方法： 添加 msvcrt.lib 到linker-&gt;输入-&gt;忽略特定默认库中，重新编译]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>windows</tag>
        <tag>libtiff</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lucene 4.6 实战 （2）检索文档]]></title>
    <url>%2F2016%2F09%2F21%2Fjava%2Flucene4.6_learn_2%2F</url>
    <content type="text"><![CDATA[检索文档利用 Lucene 进行搜索也是非常方便的。在上篇文档中介绍了如何建立索引，现在我们就要在这个索引上进行搜索以找到包含某个关键词或短语的文档。Lucene 提供了几个基础的类来完成这个过程，它们分别是 IndexSearcher, Term, Query, TermQuery, TopDocs, ScoreDoc. 下面我们分别介绍这几个类的功能。 Query这是一个抽象类，他有多个实现，比如 TermQuery, BooleanQuery, PrefixQuery. 这个类的目的是把用户输入的查询字符串封装成 Lucene 能够识别的 Query。 TermTerm 是搜索的基本单位，一个Term对象有两个String类型的域组成。生成一个 Term 对象可以有如下一条语句来完成：Term term = new Term(“fieldName”,”queryWord”); 其中第一个参数代表了要在文档的哪一个Field上进行查找，第二个参数代表了要查询的关键词。 TermQueryTermQuery 是抽象类 Query 的一个子类，它同时也是 Lucene 支持的最为基本的一个查询类。生成一个 TermQuery 对象由如下语句完成： TermQuery termQuery = new TermQuery(new Term(“fieldName”,”queryWord”));它的构造函数只接受一个参数，那就是一个 Term 对象。 IndexSearcherIndexSearcher 是用来在建立好的索引上进行搜索的。它只能以只读的方式打开一个索引，所以可以有多个 IndexSearcher 的实例在一个索引上进行操作。 TopDocsTopDocs 保存由IndexSearcher.search()方法返回的具有较高评分的顶部文档。 ScoreDoc提供对 TopDocs 中每条搜索结果的访问接口 测试 Demo各种Field搜索事例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169package test;import java.io.IOException;import org.apache.lucene.analysis.Analyzer;import org.apache.lucene.document.Document;import org.apache.lucene.index.DirectoryReader;import org.apache.lucene.index.IndexReader;import org.apache.lucene.index.Term;import org.apache.lucene.queryparser.classic.MultiFieldQueryParser;import org.apache.lucene.queryparser.classic.ParseException;import org.apache.lucene.queryparser.classic.QueryParser;import org.apache.lucene.search.BooleanQuery;import org.apache.lucene.search.IndexSearcher;import org.apache.lucene.search.NumericRangeQuery;import org.apache.lucene.search.PhraseQuery;import org.apache.lucene.search.PrefixQuery;import org.apache.lucene.search.Query;import org.apache.lucene.search.TermQuery;import org.apache.lucene.search.TermRangeQuery;import org.apache.lucene.search.TopDocs;import org.apache.lucene.store.Directory;import org.apache.lucene.util.Version;import org.wltea.analyzer.lucene.IKAnalyzer;public class Searcher &#123; public void BuildSearcher(Directory directory) &#123; try &#123; this.reader = DirectoryReader.open(directory); this.searcher = new IndexSearcher(reader); this.analyzer = new IKAnalyzer(false); //当为true时，分词器进行最大词长切分 &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public TopDocs Search(Query query, int tops) &#123; TopDocs td = null; if (query == null || this.searcher == null) &#123; return td; &#125; try &#123; td = this.searcher.search(query, tops); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return td; &#125; public Document GetDocById(int id) &#123; Document doc = null; if (this.searcher != null) &#123; try &#123; doc = this.searcher.doc(id); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; return doc; &#125; //对单个域构建查询语句 public Query BuildSingleFieldQuery(String field, String key) &#123; QueryParser parse = new QueryParser(Version.LUCENE_40, field, analyzer); //parse.setDefaultOperator(QueryParser.OR_OPERATOR); //parse.setDefaultOperator(QueryParser.AND_OPERATOR); Query query = null; try &#123; query = parse.parse(key); &#125; catch (ParseException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return query; &#125; //对多个域创建查询语句 public Query BuildMultiFieldQuery(String[] fields, String key) &#123; MultiFieldQueryParser parse=new MultiFieldQueryParser(Version.LUCENE_40,fields,analyzer); Query query = null; try &#123; query = parse.parse(key); &#125; catch (ParseException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return query; &#125; //词条搜索 public Query BuildTermQuery(String field, String key) &#123; Query query = null; query = new TermQuery(new Term(field, key)); return query; &#125; //前缀搜索 public Query BuildPrefixQuery(String field, String key) &#123; Query query = null; query = new PrefixQuery(new Term(field, key)); return query; &#125; //短语搜索 public Query BuildPhraseQuery() &#123; PhraseQuery query = new PhraseQuery(); //设置短语间允许的最大间隔 query.setSlop(2); query.add(new Term("desc", "河")); query.add(new Term("desc", "在")); return query; &#125; //通配符搜索 public Query BuildWildcardQuery() &#123; Query query = null; return query; &#125; //字符串范围搜索 public Query BuildStringRangeQuery(String field, String beg, String end, boolean begInclusive, boolean endInclusive) &#123; Query query = TermRangeQuery.newStringRange(field, beg, end, begInclusive, endInclusive); return query; &#125; //integer范围搜索 public Query BuildIntRangeQuery(String field, int beg, int end, boolean begInclusive, boolean endInclusive) &#123; Query query = NumericRangeQuery.newIntRange(field, beg, end, begInclusive, endInclusive); return query; &#125; //float范围搜索 public Query BuildFloatRangeQuery(String field, float beg, float end, boolean begInclusive, boolean endInclusive) &#123; Query query = NumericRangeQuery.newFloatRange(field, beg, end, begInclusive, endInclusive); return query; &#125; //double范围搜索 public Query BuildDoubleRangeQuery(String field, double beg, double end, boolean begInclusive, boolean endInclusive) &#123; Query query = NumericRangeQuery.newDoubleRange(field, beg, end, begInclusive, endInclusive); return query; &#125; //BooleanQuery public Query BuildBooleanQuery() &#123; BooleanQuery query = new BooleanQuery();// query.add(query_1, BooleanClause.Occur.SHOULD);// query.add(query_2, BooleanClause.Occur.SHOULD);// return query; return query; &#125; private Analyzer analyzer; private IndexReader reader; private IndexSearcher searcher;&#125; 测试程序入口：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package test;import java.util.List;import test.IndexBuilder;import test.Searcher;import org.apache.lucene.document.Document;import org.apache.lucene.index.IndexableField;import org.apache.lucene.search.BooleanClause;import org.apache.lucene.search.BooleanQuery;import org.apache.lucene.search.Query;import org.apache.lucene.search.ScoreDoc;import org.apache.lucene.search.TopDocs;import org.apache.lucene.store.Directory;public class IKAnalyzerDemo &#123; /** * @param args */ public static void main(String[] args) &#123; IndexBuilder builder = new IndexBuilder(); builder.Build(); Directory directory = builder.getDirectory(); //搜索过程********************************** Searcher searcher = new Searcher(); searcher.BuildSearcher(directory); Query query = null; TopDocs topDocs = null; String keyword = "张三北京"; String[] keys = &#123;"name", "desc"&#125;; //test-1 query = searcher.BuildSingleFieldQuery("name", keyword); //System.out.println(query.toString()); topDocs = searcher.Search(query, 5); Display(searcher, topDocs); System.out.println("-----------------------------------------------"); //test-2 query = searcher.BuildMultiFieldQuery(keys, "北京"); //System.out.println(query.toString()); topDocs = searcher.Search(query, 5); Display(searcher, topDocs); System.out.println("-----------------------------------------------"); //test-3 query = searcher.BuildTermQuery("name", "赵六"); //System.out.println(query.toString()); topDocs = searcher.Search(query, 5); Display(searcher, topDocs); System.out.println("-----------------------------------------------"); //test-4 query = searcher.BuildPrefixQuery("desc", "天津"); topDocs = searcher.Search(query, 5); Display(searcher, topDocs); System.out.println("-----------------------------------------------"); //test-5// query = searcher.BuildPhraseQuery();// System.out.println(query.toString());// topDocs = searcher.Search(query, 5);// Display(searcher, topDocs);// System.out.println("-----------------------------------------------"); //test-6 Query query1 = searcher.BuildIntRangeQuery("age", 19, 19, true, true); System.out.println(query1.toString()); topDocs = searcher.Search(query1, 5); Display(searcher, topDocs); System.out.println("-----------------------------------------------"); //test-7 BooleanQuery bq = (BooleanQuery)searcher.BuildBooleanQuery(); bq.add(query, BooleanClause.Occur.SHOULD); bq.add(query1, BooleanClause.Occur.SHOULD); topDocs = searcher.Search(bq, 5); Display(searcher, topDocs); System.out.println("-----------------------------------------------"); &#125; public static void Display(Searcher searcher, TopDocs topDocs) &#123; System.out.println("命中：" + topDocs.totalHits); //输出结果 ScoreDoc[] scoreDocs = topDocs.scoreDocs; for (int i = 0; i &lt; topDocs.totalHits; i++) &#123; Document targetDoc = searcher.GetDocById(scoreDocs[i].doc); //System.out.println("内容：" + targetDoc.toString()); List&lt;IndexableField&gt; l = targetDoc.getFields(); for (IndexableField item : l ) &#123; System.out.print(item.name() + ":" +item.stringValue() + " | "); &#125; System.out.println("score:" + scoreDocs[i].score); &#125; &#125;&#125; 输出结果12345678910111213141516171819202122加载扩展词典：ext_1.dic加载扩展停止词典：stopword.dic命中：1ID:0 | name:张三 | age:20 | time:20160919012839498 | desc:张三在北京生活，在北京工作 | score:0.501279-----------------------------------------------命中：2ID:0 | name:张三 | age:20 | time:20160919012839498 | desc:张三在北京生活，在北京工作 | score:0.3345567ID:1 | name:李四 | age:19 | time:20160919012839594 | desc:李四是河北人，在北京工作 | score:0.23656732-----------------------------------------------命中：0-----------------------------------------------命中：1ID:2 | name:王五 | age:32 | time:20160919012839595 | desc:王五是山东人，在天津工作 | score:1.0-----------------------------------------------age:[19 TO 19]命中：1ID:1 | name:李四 | age:19 | time:20160919012839594 | desc:李四是河北人，在北京工作 | score:1.0-----------------------------------------------命中：2ID:1 | name:李四 | age:19 | time:20160919012839594 | desc:李四是河北人，在北京工作 | score:0.35355338ID:2 | name:王五 | age:32 | time:20160919012839595 | desc:王五是山东人，在天津工作 | score:0.35355338-----------------------------------------------]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>lucene</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lucene 4.6 实战 （1）创建索引]]></title>
    <url>%2F2016%2F09%2F20%2Fjava%2Flucene4.6_learn_1%2F</url>
    <content type="text"><![CDATA[引言前一段时间做了一些和Lucene相关的工作，最近想把当初的学习过程，以及编写的Demo整理了一下。 搜索应用程序和 Lucene 之间的关系 建立索引建立索引主要涉及以下这几个类: DocumentDocument是用来描述文档的，这里的文档可以指一封电子邮件，或者是一个文本文件。一个Document对象由多个Field对象组成的。可以把一个Document对象想象成数据库中的一个记录，而每个Field对象就是记录的一个字段。 FieldField对象是用来描述一个文档的某个属性的，比如一封电子邮件的标题和内容可以用两个Field对象分别描述。 Analyzer在一个文档被索引之前，首先需要对文档内容进行分词处理，这部分工作就是Analyzer来做的。Analyzer类是一个抽象类，它有多个实现。针对不同的语言和应用需要选择适合的Analyzer。中文分词我们选择了IKAnalyzer 。Analyzer把分词后的内容交给IndexWriter来建立索引。 IndexWriterIndexWriter是 Lucene 用来创建索引的一个核心的类，他的作用是把一个个的 Document对象加到索引中来。 Directory这个类代表了 Lucene 的索引的存储的位置，这是一个抽象类，它目前有两个实现，第一个是FSDirectory，它表示一个存储在文件系统中的索引的位置。第二个是RAMDirectory，它表示一个存储在内存当中的索引的位置。 测试 Demo数据简单封装:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package test;import java.util.Date;public class DocumentData &#123; public DocumentData() &#123; id = 0; age = 0; &#125; public DocumentData(int id, int age, String name, String desc, Date tm) &#123; this.id = id; this.age = age; this.name = name; this.desc = desc; this.createTime = tm; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getDesc() &#123; return desc; &#125; public void setDesc(String desc) &#123; this.desc = desc; &#125; public Date getCreateTime() &#123; return createTime; &#125; public void setCreateTime(Date createTime) &#123; this.createTime = createTime; &#125; private int id; private int age; private String name; private String desc; private Date createTime;&#125; 创建数据索引:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package test;import test.DocumentData;import java.io.IOException;import java.util.Date;import org.apache.lucene.analysis.Analyzer;import org.apache.lucene.document.DateTools;import org.apache.lucene.document.Document;import org.apache.lucene.document.Field;import org.apache.lucene.document.IntField;import org.apache.lucene.document.TextField;import org.apache.lucene.index.IndexWriter;import org.apache.lucene.index.IndexWriterConfig;import org.apache.lucene.index.IndexWriterConfig.OpenMode;import org.apache.lucene.store.Directory;import org.apache.lucene.store.RAMDirectory;import org.apache.lucene.util.Version;import org.wltea.analyzer.lucene.IKAnalyzer;public class IndexBuilder &#123; public void Build() &#123; String s1 = "张三在北京生活，在北京工作"; String s2 = "李四是河北人，在北京工作"; String s3 = "王五是山东人，在天津工作"; String s4 = "赵六是河南人，在深圳工作"; String s5 = "赵四是东北人，在深圳工作"; //实例化IKAnalyzer分词器 Analyzer analyzer = new IKAnalyzer(); //内存中创建索引 directory = new RAMDirectory(); //创建索引保存到硬盘中 //File dataPath = new File("E:\\java_workspace\\LuceneData\\data"); //directory = FSDirectory.open(dataPath); IndexWriterConfig iwConfig = new IndexWriterConfig(Version.LUCENE_40, analyzer); iwConfig.setOpenMode(OpenMode.CREATE_OR_APPEND); IndexWriter iWriter = null; try &#123; iWriter = new IndexWriter(directory, iwConfig); //1 DocumentData data1 = new DocumentData(0, 20, "张三", s1, new Date()); Document doc_1 = GenDoc(data1); //2 DocumentData data2 = new DocumentData(1, 19, "李四", s2, new Date()); Document doc_2 = GenDoc(data2); //3 DocumentData data3 = new DocumentData(2, 32, "王五", s3, new Date()); Document doc_3 = GenDoc(data3); //4 DocumentData data4 = new DocumentData(3, 44, "赵六", s4, new Date()); Document doc_4 = GenDoc(data4); //5 DocumentData data5 = new DocumentData(4, 28, "赵四", s5, new Date()); Document doc_5 = GenDoc(data5); //添加 iWriter.addDocument(doc_1); iWriter.addDocument(doc_2); iWriter.addDocument(doc_3); iWriter.addDocument(doc_4); iWriter.addDocument(doc_5); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; try &#123; if (iWriter != null) &#123; iWriter.close(); &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; protected Document GenDoc(DocumentData data) &#123; String tm1 = DateTools.dateToString(data.getCreateTime(), DateTools.Resolution.MILLISECOND); Document d = new Document(); d.add(new Field("ID", new Integer(data.getId()).toString(), TextField.TYPE_STORED)); d.add(new Field("name", data.getName(), TextField.TYPE_STORED)); d.add(new IntField("age", data.getAge(), Field.Store.YES)); d.add(new Field("time", tm1, TextField.TYPE_STORED)); d.add(new Field("desc", data.getDesc(), TextField.TYPE_STORED)); return d; &#125; public Directory getDirectory() &#123; return directory; &#125; public void setDirectory(Directory directory) &#123; this.directory = directory; &#125; private Directory directory;&#125;]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>lucene</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IK中文分词的使用]]></title>
    <url>%2F2016%2F09%2F19%2Fjava%2FIK_learn%2F</url>
    <content type="text"><![CDATA[下载 IKAnalyzerIKAnalyzer 提取密码: wuq4 压缩包内容： IKAnalyzer2012FF_u1.jar (IKAnalyzer核心jar包) IKAnalyzer.cfg.xml (配置文件，可以在这里配置停词表和扩展词库) IKAnalyzer中文分词器V2012_FF使用手册.pdf (使用手册) stopword.dic (停词表, 过滤词) 配置文件配置是否加载，以及加载哪些扩展字典和停止词字典，配置文件和扩展文件都放到程序输出路径下1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd"&gt; &lt;properties&gt; &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt; &lt;!--用户可以在这里配置自己的扩展字典 &lt;entry key="ext_dict"&gt;ext_1.dic;ext_2.dic;&lt;/entry&gt; --&gt; &lt;!--用户可以在这里配置自己的扩展停止词字典 &lt;entry key="ext_stopwords"&gt;stopword_1.dic;stopword_2.dic;&lt;/entry&gt; --&gt; &lt;/properties&gt; 单独使用IK进行分词123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package test;import java.io.BufferedReader;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.StringReader;import org.wltea.analyzer.cfg.DefaultConfig;import org.wltea.analyzer.core.IKSegmenter;import org.wltea.analyzer.core.Lexeme;import org.wltea.analyzer.dic.Dictionary;public class IKTest &#123; public static void main(String[] args) &#123; // 载入字典 Dictionary.initial(DefaultConfig.getInstance()); String text = "公文编辑器是大数据的电子文档的2016里约奥运会"; System.out.println("原文：" + text); System.out.println("------------------------------"); // 创建分词对象 StringReader reader = new StringReader(text); //写 OutputStreamWriter out = null; File f = new File("out.txt"); IKSegmenter ik = new IKSegmenter(reader,true);//当为true时，分词器进行最大词长切分 try &#123; out = new OutputStreamWriter(new FileOutputStream(f), "UTF-8"); Lexeme lexeme = null; while((lexeme = ik.next())!=null) &#123; System.out.println(lexeme.getLexemeText()); out.write(lexeme.getLexemeText()+"\n"); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally&#123; reader.close(); try &#123; if (out != null) &#123; out.close(); &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; 运行结果未使用扩展词典和停止词典1234567891011121314原文：公文编辑器是大数据的电子文档的2016里约奥运会------------------------------公文编辑器是大数据的电子文档的2016里约奥运会 使用扩展词典和停止词典扩展词典和停用词典文件的编码必须是UTF-8 扩展词典内容： 2016里约奥运会电子文档大数据 停止词典内容： 是的 123456789加载扩展词典：ext_1.dic加载扩展停止词典：stopword.dic原文：公文编辑器是大数据的电子文档的2016里约奥运会------------------------------公文编辑器大数据电子文档2016里约奥运会]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>IKAnalyzer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 标准库 urllib2 的使用细节]]></title>
    <url>%2F2016%2F08%2F24%2Fpython%2Fpython_url2_learn%2F</url>
    <content type="text"><![CDATA[转自：http://zhuoqiang.me/python-urllib2-usage.html Python 标准库 urllib2 的使用细节Python 标准库中有很多实用的工具类，但是在具体使用时，标准库文档上对使用细节描述的并不清楚，比如 urllib2 这个 HTTP 客户端库。这里总结了一些 urllib2 的使用细节。 Proxy 的设置 Timeout 设置 在 HTTP Request 中加入特定的 Header Redirect Cookie 使用 HTTP 的 PUT 和 DELETE 方法 得到 HTTP 的返回码 Debug Log Proxy 的设置urllib2 默认会使用环境变量 http_proxy 来设置 HTTP Proxy。如果想在程序中明确控制 Proxy 而不受环境变量的影响，可以使用下面的方式 123456789101112import urllib2enable_proxy = Trueproxy_handler = urllib2.ProxyHandler(&#123;"http" : 'http://some-proxy.com:8080'&#125;)null_proxy_handler = urllib2.ProxyHandler(&#123;&#125;)if enable_proxy: opener = urllib2.build_opener(proxy_handler)else: opener = urllib2.build_opener(null_proxy_handler) urllib2.install_opener(opener) 这里要注意的一个细节，使用 urllib2.install_opener() 会设置 urllib2 的全局 opener 。这样后面的使用会很方便，但不能做更细粒度的控制，比如想在程序中使用两个不同的 Proxy 设置等。比较好的做法是不使用 install_opener 去更改全局的设置，而只是直接调用 opener 的 open 方法代替全局的 urlopen 方法。 Timeout 设置在老版 Python 中，urllib2 的 API 并没有暴露 Timeout 的设置，要设置 Timeout 值，只能更改 Socket 的全局 Timeout 值。 12345import urllib2import socketsocket.setdefaulttimeout(10) # 10 秒钟后超时urllib2.socket.setdefaulttimeout(10) # 另一种方式 在 Python 2.6 以后，超时可以通过 urllib2.urlopen() 的 timeout 参数直接设置。12import urllib2response = urllib2.urlopen('http://www.google.com', timeout=10) 在 HTTP Request 中加入特定的 Header要加入 header，需要使用 Request 对象： 12345import urllib2request = urllib2.Request(uri)request.add_header('User-Agent', 'fake-client')response = urllib2.urlopen(request) 对有些 header 要特别留意，服务器会针对这些 header 做检查 User-Agent : 有些服务器或 Proxy 会通过该值来判断是否是浏览器发出的请求 Content-Type : 在使用 REST 接口时，服务器会检查该值，用来确定 HTTP Body 中的内容该怎样解析。常见的取值有： application/xml ： 在 XML RPC，如 RESTful/SOAP 调用时使用 application/json ： 在 JSON RPC 调用时使用 application/x-www-form-urlencoded ： 浏览器提交 Web 表单时使用 在使用服务器提供的 RESTful 或 SOAP 服务时， Content-Type 设置错误会导致服务器拒绝服务 Redirecturllib2 默认情况下会针对 HTTP 3XX 返回码自动进行 redirect 动作，无需人工配置。要检测是否发生了 redirect 动作，只要检查一下 Response 的 URL 和 Request 的 URL 是否一致就可以了。 123import urllib2response = urllib2.urlopen('http://www.google.cn')redirected = response.geturl() == 'http://www.google.cn' 如果不想自动 redirect，除了使用更低层次的 httplib 库之外，还可以自定义 HTTPRedirectHandler 类。 12345678910import urllib2class RedirectHandler(urllib2.HTTPRedirectHandler): def http_error_301(self, req, fp, code, msg, headers): pass def http_error_302(self, req, fp, code, msg, headers): passopener = urllib2.build_opener(RedirectHandler)opener.open('http://www.google.cn') Cookieurllib2 对 Cookie 的处理也是自动的。如果需要得到某个 Cookie 项的值，可以这么做： 123456789import urllib2import cookielibcookie = cookielib.CookieJar()opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))response = opener.open('http://www.google.com')for item in cookie: if item.name == 'some_cookie_item_name': print item.value 使用 HTTP 的 PUT 和 DELETE 方法urllib2 只支持 HTTP 的 GET 和 POST 方法，如果要使用 HTTP PUT 和 DELETE ，只能使用比较低层的 httplib 库。虽然如此，我们还是能通过下面的方式，使 urllib2 能够发出 PUT 或 DELETE 的请求： 12345import urllib2request = urllib2.Request(uri, data=data)request.get_method = lambda: 'PUT' # or 'DELETE'response = urllib2.urlopen(request) 这种做法虽然属于 Hack 的方式，但实际使用起来也没什么问题。 得到 HTTP 的返回码对于 200 OK 来说，只要使用 urlopen 返回的 response 对象的 getcode() 方法就可以得到 HTTP 的返回码。但对其它返回码来说，urlopen 会抛出异常。这时候，就要检查异常对象的 code 属性了： 12345import urllib2try: response = urllib2.urlopen('http://restrict.web.com')except urllib2.HTTPError, e: print e.code Debug Log使用 urllib2 时，可以通过下面的方法把 debug Log 打开，这样收发包的内容就会在屏幕上打印出来，方便调试，有时可以省去抓包的工作 12345678import urllib2httpHandler = urllib2.HTTPHandler(debuglevel=1)httpsHandler = urllib2.HTTPSHandler(debuglevel=1)opener = urllib2.build_opener(httpHandler, httpsHandler)urllib2.install_opener(opener)response = urllib2.urlopen('http://www.google.com')]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>urllib2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python相对导入机制详解]]></title>
    <url>%2F2016%2F08%2F24%2Fpython%2Fpython_xiang_dui_dao_ru_learn%2F</url>
    <content type="text"><![CDATA[转自: https://laike9m.com/blog/pythonxiang-dui-dao-ru-ji-zhi-xiang-jie,60/ Python相对导入机制详解本文是对 http://stackoverflow.com/questions/14132789/python-relative-imports-for-the-billionth-time#answer-14132912 这个 SO 答案的翻译。本人的翻译一向只追求含义准确而不追求字字对应，有些不好翻的术语或者固定说法就直接保留。 这个答案能解释大多关于 relative import，即相对导入的疑惑，讲解十分详尽清晰，算是 SO 上被低估的一个答案。 问题不翻译了，直接摘录下来：The forever-recurring question is this: With Windows 7, 32-bit Python 2.7.3, how do I solve this “Attempted relative import in non-package” message? I built an exact replica of the package on pep-0328: 12345678910111213141516171819package/ __init__.py subpackage1/ __init__.py moduleX.py moduleY.py subpackage2/ __init__.py moduleZ.py moduleA.py I did make functions named spam and eggs in their appropriate modules. Naturally, it didn’t work. The answer is apparently in the 4th URL I listed, but it’s all alumni to me. There was this response on one of the URLs I visited: Relative imports use a module’s name attribute to determine that module’s position in the package hierarchy. If the module’s name does not contain any package information (e.g. it is set to’main’) then relative imports are resolved as if the module were a top level module, regardless of where the module is actually located on the file system. The above response looks promising, but it’s all hieroglyphs to me. So my question, how do I make Python not return to me”Attempted relative import in non-package”? has an answer that involves -m, supposedly. Can somebody please tell me why Python gives that error message, what it Means by non-package!, why and how do you define a ‘package’, and the precise answer put in terms easy enough for a kindergartener to understand. Thanks in advance! Edit: The imports were done from the console. BrenBarn 的精彩答案（这个哥们可以算是 import 专家了，答了好多这方面的题） 简单地说，直接运行 .py 文件和 import 这个文件有很大区别。Python 解释器判断一个 py 文件属于哪个 package 时并不完全由该文件所在的文件夹决定。它还取决于这个文件是如何 load 进来的（直接运行 or import）。 有两种方式加载一个 py 文件：作为 top-level 脚本或者作为 module。前者指的是直接运行脚本，比如 python myfile.py。如果执行 python -m myfile，或者在其它 py 文件中用 import 语句来加载，那么它就会被当作一个 module。有且只能有一个 top-level 脚本，就是最开始执行的那个（比如 python myfile.py 中的 myfile.py，译者注）。 当一个 py 文件被加载之后，它会被赋予一个名字，保存在 __name__ 属性中。如果是 top-level 脚本，那么名字就是 __main__。如果是作为 module，名字就是把它所在的 packages/subpackages 和文件名用 . 连接起来。 例如，moduleX 被 import 进来，它的名字就是 package.subpackage1.moduleX。如果 import 了 moduleA，它的名字是 package.moduleA。如果直接运行 moduleX 或 moduleA，那么名字就都是 __main__了。 另一个令人担忧的问题是，一个 module 的名字取决于它是直接从它所在的文件夹 import 还是通过某个 package import 的。不过只有当你在某个路径中运行 Python 并试图从当前文件夹 import 一个 py 文件时，才需要关注它们的不同。例如，在路径 pacakge/subpackage1 中运行 python 解释器，然后脚本中有 import moduleX 这个语句，此时 moduleX 的名字正是 moduleX，而不是 package.subpackage1.moduleX。这是因为 Python 解释器在启动时把当前路径（这里答案写的不准确，其实加入的是 top-level 脚本的路径，因为两者在这种状况下相同，所以也并不算错。译者注）加入了它的搜索路径 (sys.path)；如果发现要 import 的 module 就在当前路径，那么 Python 解释器就不知道当前路径是属于哪个 package 的，所以 pacakge 的信息就不会成为 module 的名字的一部分。 一个特例是直接运行 python REPL，这个 REPL 的 session 的名字是 __main__。 关于你遇到的错误信息，关键点来了：如果一个 module 的名字中没有点（即 package.subpackage1 中的那个点，译者注），那么它就被认为不属于任何一个 package。文件在磁盘上的位置在哪里都不影响，唯一起决定作用的就是 module 的名字，而这又取决于它是如何被加载的。 先在我们看看你在问题中引用的这段话 Relative imports use a module’s name attribute to determine that module’s position in the package hierarchy. If the module’s name does not contain any package information (e.g. it is set to’main’) then relative imports are resolved as if the module were a top level module, regardless of where the module is actually located on the file system. relative import 使用 module 的名字来决定它是否属于一个 package，属于哪个 package。当你使用这种 relative import from .. import foo，其中的点的数量代表了 package 结构中的某个层次。例如，如果当前 module 的名字是 package.subpackage1.moduleX，那么..moduleA 代表 package.moduleA。为了让形如 from .. import 的这种导入能够正常工作，module 的名字里的点数量应当至少和 import 语句中一样多。 前面说了，如果 module 的名字是 __main__，那么 Python 就不认为它属于某个 package。由于名字里不包含点，所以在这个 py 文件中 from .. import 语句无法正常工作。试图执行这条语句就会报 “relative-import in non-package” 错误。 你犯的错误可能是从命令行运行 moduleX 或类似的操作。当你执行这个操作，moduleX 的名字被设置成 __main__，所以 relative imports 失败了，因为不包含 package 信息。正如前面说的，如果在同一个路径里 import 一个文件，这时 module 的名字就是文件名，不包含 package 信息，所以相对导入也会失败。 记住，因为 REPL session 的名字总是 __main__，所以试图在 REPL 里执行 relative import 是不行的。relative import 应当只在 module 文件中被使用。 （无法相对导入的问题）有两个解决方法。如果你真的想直接运行 moduleX，同时又希望它被当作所在 package 的一部分，可以这么做：python -m package.subpackage.moduleX。-m 参数告诉 Python 解释器，把这个文件当作一个 module 载入，而不是 top-level 脚本。 如果你并不想直接运行 moduleX，而是想在另一个文件比如 myfile.py 中使用 moduleX 中定义的函数，那么解决方法是把 myfile.py 文件挪到另一个地方，只要不在 moduleX 所属的 package 的文件夹里就行。然后在 myfile.py 中执行 from package.moduleA import spam，就能正常工作了。 注意，不论哪种解决方案，都需要 package 的路径（上文中的 package）在 python 的搜索路径也就是 sys.path 里。如果不在，那么就无法使用这个 package 中的任何文件。 （更严谨的说明：从 Python2.6 开始，在做 package-resolution 时，module 的 “名字” 并不完全等于 __name__属性，还和 __package__ 属性有关。这也是为什么上文中我一直尽量避免用 __name__来指代 module 的名字。从 python2.6 开始，一个 module 的 “名字” 实际上是 __package__ + &#39;.&#39; + __name__, 或者直接就是 __name__，如果 __package__ 是 None 的话）]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 6.5 安装Scrapy]]></title>
    <url>%2F2016%2F07%2F03%2Fenv%2FCentOS6.5-install-scrapy%2F</url>
    <content type="text"><![CDATA[CentOS 6.5 Python升级到Python2.7下载源码 https://www.python.org/downloads/release/python-2712/123$ tar xvf Python-2.7.12.tgz$ ./configure --prefix=/usr/local/python2.7.12$ make &amp;&amp; make install 在/usr/bin/下建立符号链接指向安装好的python12ln -s /usr/local/python2.7.12/bin/python2.7 /usr/bin/pythonln -s /usr/local/python2.7.12/bin/python2.7-config /usr/bin/python-config 升级后yum不可用，修改/usr/bin/yum文件：1#!/usr/bin/python --&gt; #!/usr/bin/python2.6 安装依赖包:123$ yum install python-lxml$ yum install libxml2-devel$ yum install libxslt-devel 安装setup-tools:12wget --no-check-certificate https://bootstrap.pypa.io/ez_setup.py -O - | pythonln -s /usr/local/python2.7.12/bin/easy_install-2.7 /usr/bin/easy_install 安装pip:123$ easy_install pip$ pip install service-identity$ pip install scrapy 测试scrapy:1scrapy bench]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Install Scrapy]]></title>
    <url>%2F2016%2F06%2F30%2Fenv%2Finstall-scrapy%2F</url>
    <content type="text"><![CDATA[安装 python1$ sudo apt-get install python2.7 安装 setuptools1$ wget https://bootstrap.pypa.io/ez_setup.py -O - | sudo python 安装 pip1$ sudo easy_install pip 安装 scrapy1$ sudo pip Scrapy 问题 安装scrapy出现, Python.h: No such file or directory 解决方法是安装python-dev，这是Python的头文件和静态库包: 1$ sudo apt-get install python-dev]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2016%2F05%2F22%2Fhexo%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
